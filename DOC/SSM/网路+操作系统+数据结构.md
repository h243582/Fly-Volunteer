# 一、计算机网络

## 1、`http`

### 1、概念

超文本传输协议

### 2、http协议的组成

包括请求 和 响应，在网页地址栏输入一个地址之后，浏览器会把请求发送给服务器，服务器收到响应，返回信息给浏览器

### 3、http请求

#### （1）请求头

==主机名，cookie，User-Agent==

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/202109022055175.png" alt="img" style="zoom: 50%;" />

#### （2）请求行

==请求方式（post、get）、请求的资源 内容==

#### （3）请求体

 当请求方式是post时，请求体会有请求参数格式如下：

    username=zhangsan&password=123
当请求方式时get时，请求参数是不会出现在请求体中，会拼接在url地址后面：

```
http://localhost:8080...？username=zhangsan&password=123
```

### 4、http响应

#### （1）响应头

location路径，Content-Disposition解析的资源，Set-Cookie设置cookie

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/202109022126248.png" alt="img" style="zoom:50%;" />

#### （2）响应行

包括==状态码== 返回给客户端

#### （3）响应体

**显示正文页面内容**，返回给客户端



## 2、HTTPS

### 核心SSL/TLS协议

SSL 指安全套接字协议，1999 年，SSL 3.0 进一步升级，**新版本被命名为 TLS 1.0**

SSL/TLS 的核心要素是**非对称加密**。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，

### 公钥传输的信赖性

为了公钥传输的信赖性问题，**CA** 会给各个服务器颁发证书，当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。

### 数字签名



## 3、HTTP和HTTPS区别

**端口号** ：HTTP 默认是 80，HTTPS 默认是 443。

**UTL 前缀** ：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。

**安全性和资源消耗** ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。

## 4、应用层协议

### HTTP:超文本传输协议

### SMTP:简单邮件传输(发送)协议

### POP3/IMAP:邮件接收的协议

### FTP:文件传输协议

**基于 TCP 实现可靠的传输**。使用 `FTP` 传输文件的好处是可以屏蔽操作系统和文件存储方式。

在客户端与 FTP 服务器之间建立两个连接

1. **控制**连接：用于传送控制信息（命令和响应）
2. **数据**连接：用于数据传送；

这种将命令和数据分开传送的思想大大提高了 FTP 的效率

### Telnet:远程登陆协议

明文发送

### SSH:安全的网络传输协议

加密发送






## 5、`Tcp/Ip`

### 1、**它的模型，做了事情**

TCP/IP模型分为五层，分别是应用层，传输层，网络层，数据链路层，物理层

TCP/IP协议群主要是==报文的拆分==，增加协议头，==数据的传输==，==路由和寻址以及数据的重组==

### 2、**建立连接-三次握手**

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/image-20220304164501043.png" alt="image-20220304164501043" style="zoom:50%;" />

1. 主机A发送syn到主机B，要求建立a到b的连接。（**此时主机A的状态为syn_sent**）

2. 主机B回复`ack`+`syn`，要求建立b到a的连接，主机B的状态为syn_rcvd

   - （这里的`ack`和`syn`数据报本来是两个，但是==仅标志位不同，可以合并==,所以为什么不是四次的原因）

3. 主机A回复B中`syn`的`ack`。主机A的状态为established，建立A到B的连接

   **最后：**主机B接收到第3步的数据报，建立B到A 的连接，主机B的状态置为established

### **断开连接-四次挥手**

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/image-20220304164434033.png" alt="image-20220304164434033" style="zoom:50%;" />

1. 主机A发送`fin`到主机B，请求关闭a到b的连接
2. 主机B回复`ack`，主机B的状态置为close_wait（**表示可以关闭了**）
3. 主机B发送`fin`到主机A，请求关闭b到a的连接
4. 值即A回复`ack`（第三步的`fin`），状态置为time_wait（**表示可以关闭了**）

之后：主机B接收到第四步的数据报，状态置为closed

最后：主机A经过2MSL（超时等待时间）之后，状态置为closed

#### 为什么挥手要4次

因为当服务器收到客户端发的断开请求之后，服务器虽然可以直接断开连接了，但是服务器可能还正在给客户端发数据，一时半会儿发不完！所有要等一会儿再发送，不能一起发。

### 7、**TCP和UDP的区别**

![image-20220304164804021](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/image-20220304164804021.png)

1. TCP是有连接的可靠传输协议，而UDP是无连接的
2. UDP传时数据是有大小限制的，而TCP没有
3. UDP是面向数据报的，而TCP是面向数据流的
4. TCP保证数据正确性，顺序性，而UDP不能保证

## 6、TCP 协议如何保证可靠传输

1. 应用数据被分割成 TCP 认为最适合发送的数据块。
2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3. **校验和：** TCP 将保持它**首部**和**数据**的检验和。检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃和不收它。
4. TCP 的接收端会丢弃重复的数据。
5. **流量控制：** TCP 连接的每一方都有**固定大小的缓冲空间**，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能**提示发送方降低发送的速率**，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口(=窗口大小告诉你 我接收方的容器有多大==)实现流量控制）
6. **拥塞控制：** 当网络拥塞时，减少数据的发送。
7. **ARQ 协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

#### ARQ 协议

**自动重传请求（ARQ）**是 OSI 模型中数据链路层和传输层的错误纠正协议之一；如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送

## 7、URI 和 URL 的区别是什么?

- UR**I**(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
- UR**L**(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。





## 9、正向代理和反向代理的区别

==正向代理==：要访问的服务器==**只知道代理服务器**==来访问它，并==**不知道真实的客户端**==是谁

==反向代理==：反向代理正好相反。对于客户端来说，反向代理就好像目标服务器，客户端向反向代理发送请求，接着反向代理判断请求走向何处，隐藏了真实的服务器



## 10、DNS解析（DNS找IP）

当浏览器中输入www.baidu.com域名时，操作系统会检查自己本地的hosts文件查看是否有这个网址的映射关系，如果有，直接调用

如果没有，则查找本地的DNS解析器缓存，如果有，则直接返回IP

如果没有，再找TCP/IP参数中设置的本地的DNS服务器，如果该域名包含再本地配置区域的资源中，则返回解析结果。

也可能查找的域名，本地的DNS服务器已经缓存在网址的映射关系，那么直接调用这个IP

如果本地DNS服务器也无法解析，会根据本地的DNS服务器是否设置转发器进行查询

如果是未转发模式，本地DNS会把请求发给13台根DNS，由对应的根服务器（例如.com）向下找，最后完成解析

如果是转发模式，那么DNS服务器会把请求一级一级向上传，往上找，直到传到根DNS

## GET和POST的区别

get的请求数据只能放在url中，post的数据，可以放在url和请求体

**url长度有限制，所有get方法请求数据不能太多**，并且url只能传输ascli字符

POST安全性高，post可以存放请求数据在请求体，相对更加安全

GET主要是从服务端获取数据，而POST请求主要是将数据发送到服务端

POST请求刷新会被重新提交，但Get请求不会

## 常见的状态码

400:客户端请求语法错误，服务端无法理解

405：映射找到了，但是客户端请求方法和服务端提供的请求方法不匹配

500:服务端内部报错

403：无权限

## 输入一个URL到浏览器中，会发生什么

域名解析(DNS解析)

发起TCP的三次握手

建立TCP连接后发起HTTP请求（如果浏览器存储了该域名下的Cookies，那么会把Cookies放入HTTP请求头里发给服务器）

服务器端响应http请求，浏览器得到html代码

浏览器解析html代码，并请求html代码中的资源

浏览器对页面进行渲染呈现给用户

# 二、操作系统

## 1、系统调用

进程在系统上的运行级别分为用户态和系统态

- 用户态：用户可以直接读取的程序的数据
- 系统态：系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。

所以说与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。

## 2、进程/线程、通信/同步

### （1）**进程和线程**的区别

一个进程里面装着多个线程，这些线程都是分别从主内存中拷贝的一个工作空间，都是私有的，线程里面包括了虚拟机栈、本地方法栈和程序计数器，程序计数器决定了这个线程运行到了哪一步。但他们共享堆了内存。

### （2）**通信与同步**的区别

**通信**是为了让进程/线程==**有顺序执行**==；同步是为了让进程/线程在执行时==**不被抢占**==（上锁）

### （3）、**进程**间**通信**方式



- **匿名管道**：亲属关系的进程
- **有名管道**：严格遵循先进先出（队列）
- **共享内存**：多个进程访问同一个数据，但是需要加互斥锁
- **信号**：
- **信号量**：用于多个进程对于共享数据的访问（拥塞控制）
- **消息队列**：
- **套接字Sockeet**：

### （4）、线程间通信方式

`（为什么要通信：保证线程有规律的执行，因为默认情况下CPU是随机切换线程）`

（什么是线程通信：多个线程在处理**同一个资源**，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的**使用或操作**。）

#### 1、使用 `volatile` 关键字

```java
//定义一个共享变量来实现通信，它需要是volatile修饰，否则线程不能及时感知
static volatile boolean notice = false;
```

多个线程同时监听一个变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。这也是最简单的一种实现方式

#### 2、Object类的`wait()，notify() `

==Object类提供了线程间通信的方法：`wait()`、`notify()`、`notifyaAl()`==

**注意： wait和 notify必须配合synchronized使用，wait方法释放锁，notify方法不释放锁**

程A发出notify()唤醒通知之后，依然是走完了自己线程的业务之后，线程B才开始执行，这也正好说明了，notify()方法不释放锁，而wait()方法释放锁。

```java
public class TestSync {
    public static void main(String[] args) throws InterruptedException {
        // 定义一个锁对象
        Object lock = new Object();
        List<String> list = new ArrayList<>();
        // 实现线程A
        Thread threadA = new Thread(() -> {
            synchronized (lock) {
                for (int i = 1; i <= 10; i++) {
                    list.add("abc");
                    System.out.println("线程A向list中添加一个元素，此时list中的元素个数为：" + list.size());
                    Thread.sleep(500);
                    if (list.size() == 5)  lock.notify();// 唤醒B线程
                }
            }
        });
        // 实现线程B
        Thread threadB = new Thread(() -> {
            while (true) {
                synchronized (lock) {
                    if (list.size() != 5)   lock.wait();
                    System.out.println("线程B收到通知，开始执行自己的业务...");
                }
            }
        });
        //　需要先启动线程B
        threadB.start();
        Thread.sleep(1000);
        // 再启动线程A
        threadA.start();
    }
}
```

#### 3、JUC工具类 `CountDownLatch`

`jdk1.5`之后在`java.util.concurrent`包下提供了很多并发编程相关的工具类，简化了我们的并发编程代码的书写，`CountDownLatch`基于AQS框架，相当于也是维护了一个线程间共享变量state

```java
public class TestSync4 {
    public static void main(String[] args) {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        List<String> list = new ArrayList<>();
        // 实现线程A
        Thread threadA = new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                list.add("abc");
                System.out.println("线程A向list中添加一个元素，此时list中的元素个数为：" + list.size());
                if (list.size() == 5)
                    countDownLatch.countDown();//用于使计数器减一，其一般是执行任务的线程调用
            }
        });
        // 实现线程B
        Thread threadB = new Thread(() -> {
            if (list.size() != 5)      countDownLatch.await(); //主线程唤醒
            System.out.println("线程B收到通知，开始执行自己的业务...");
        });
        //　需要先启动线程B
        threadB.start();
        Thread.sleep(1000);

        // 再启动线程A
        threadA.start();
    }
}
```

#### 4、 ReentrantLock 结合 Condition

这种方式并不是很好，代码编写复杂，A在唤醒操作之后，并不释放锁。这种方法跟 ***Object*** 的 ***wait()*** 和 ***notify()*** 一样。

```java
public class TestSync3 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();

        ReentrantLock lock = new ReentrantLock();
        Condition condition = lock.newCondition();

        // 实现线程A
        Thread threadA = new Thread(() -> {
            lock.lock();  //加锁
            for (int i = 1; i <= 10; i++) {
                list.add("abc");
                System.out.println("线程A向list中添加一个元素，此时list中的元素个数为：" + list.size());
                Thread.sleep(500);
                if (list.size() == 5)
                    condition.signal();  //唤醒等待的线程，但是等待的还是要等自己先执行完释放
            }
            lock.unlock();
        });
        // 实现线程B
        Thread threadB = new Thread(() -> {
            lock.lock();
            System.out.println("先执行B");
            if (list.size() != 5) {
                 condition.await(); //让线程B进入等待,执行别的线程
            }
            System.out.println("线程B收到通知，开始执行自己的业务...");
            lock.unlock(); //释放锁
        });

        threadB.start();
        Thread.sleep(1000);
        threadA.start();
    }
}
```

#### 5、LockSupport实现线程间阻塞唤醒

***LockSupport*** 是一种非常灵活的实现线程间阻塞和唤醒的工具，使用它不用关注是等待线程先进行还是唤醒线程先运行，但是得知道线程的名字。

```java
public class TestSync2 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        // 实现线程B
        final Thread threadB = new Thread(() -> {
            if (list.size() != 5) {
                LockSupport.park(); //挂起当前线程
            }
            System.out.println("线程B收到通知，开始执行自己的业务...");
        });
        // 实现线程A
        Thread threadA = new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                list.add("abc");
                System.out.println("线程A向list中添加一个元素，此时list中的元素个数为：" + list.size());
                Thread.sleep(500);
                if (list.size() == 5)
                    LockSupport.unpark(threadB);//恢复threadB线程
            }
        });
        threadA.start();
        threadB.start();
    }
}
```



### （5）**线程**同步机制

同步是为了几个线程==**并发**==执行线程，如下图，不重叠

![](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/7557373-da64ffd6d1effaac.jpg)

进程中线程同步的四种常用方式：

#### 1、互斥量(互斥锁)

采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。

#### 2、信号量（拥塞控制）

它允许同一时刻**多个线程来访问同一资源**，但是需要控制同一时刻访问此资源的**==最大线程数量==**。

#### 3、事件（信号）

通过通知操作的方式来保持多线程同步，还可以方便实现多线程优先级的比较。

#### 4、临界区(锁住的代码段)

临界区对象和互斥对象非常相似，只是互斥量允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效率。
临界区： 当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止。

## 3 、进程的调度算法

1. 先来先服务FCFS
2. 短作业优先**SJF**
3. 时间片轮转
   - 每个进程分配时间段（片）过了时间直接切换进程。
4. 多级反馈
   - 设置多个就绪队列，每个队列赋予优先级；每个队列按照FCFS排序；优先级越高的队列时间片越小
5. 优先级调度

## 4、死锁的条件

首先资源A被开启了互斥锁，其他进程只能等待它被释放，而且另一个进程开启了自旋锁，只要拿不到这个资源的锁，就一直自旋等待。

## 5、内存管理主要是做什么

分配与回收（malloc 函数：申请内存，free 函数：释放内存）

地址转换（逻辑地址转换成相应的物理地址）

## 6、内存管理机制

1. 连续分配管理方式
   1. **块式管理**
      - 一块只包含一个进程，如果一个进程只需要一丢丢空间，就很浪费，这个块里面没被用的空间叫碎片
2. ==非==连续分配管理方式
   1. **页式管理**
      - 增大版的块
   2. **段式管理** 
      - 一段一段的，比如一个程序段
   3. **段页式管理**
      - 分为很多段，每个段分为很多页

## 7、页面置换算法

是否缺页：被替换了

1. **OPT** （最佳页面置换算法）

   - 从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。

   - | 访问页面 | 7    | 0    | 1    | 2    | 0    | 3    | 0    | 4    | 2    | 3    | 0    | 3    | 2    | 1    | 2    | 0    | 1    | 7    |
     | -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
     | 物理块1  | 7    | 7    | 7    | 2    |      | 2    |      | 2    |      |      | 2    |      |      | 2    |      |      |      | 7    |
     | 物理块2  |      | 0    | 0    | 0    |      | 0    |      | 4    |      |      | 0    |      |      | 0    |      |      |      | 0    |
     | 物理块3  |      |      | 1    | 1    |      | 3    |      | 3    |      |      | 3    |      |      | 1    |      |      |      | 1    |
     | 缺页否   | √    | √    | √    | √    |      | √    |      | √    |      |      | √    |      |      | √    |      |      |      | √    |

1. **FIFO** （先进先出页面置换算法）
   - **最早来过的**页面最先移出
2. **LRU最久未使用算法**
   - **最早未被使用的**页面最先移出
3. **LFU最不经常使用**
   - 看之前**被置换最少**的先被置换

# 三、数据结构

## 1、栈

![栈](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%A0%88.png)

### （1）java实现栈Stack

```java
    Stack<Integer> stack = new Stack<Integer>();
```

- `push()`：入栈
- `pop()`：返回栈顶元素并出栈
- `peek()` :返回栈顶元素**不**出栈
- `isEmpty()`:
- `size()`

## 2、堆

特征：每一个节点值都大于等于（或小于等于）子树中任意节点的值



## 3、树

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/image-20220307142649321.png" alt="image-20220307142649321" style="zoom: 50%;" />

### （1）排序二叉树(BST)

又称**二叉查找树**（Binary Search Tree），亦称**二叉搜索树**。

特征：

1. 左<父，父<右

2. 孩子均可为空

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20190708213538773.png" alt="在这里插入图片描述" style="zoom: 33%;" />

缺点：

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/image-20220307143336503.png" alt="image-20220307143336503" style="zoom: 25%;" />



### （2）完全二叉树

1. 除**末尾层**外，其它各层的结点数都达到最大个数，（只有**最右下角**末尾可以没有节点）

   

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210721194724.png" alt="img" style="zoom: 67%;" /><img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210721091410.png" alt="image-20210721091410629" style="zoom: 80%;" />



### （3）平衡二叉树(二叉排序树)

#### 特征：

1. ==包括排序二叉树的特征==
2. 所有子树**平衡因子** <= 1   （平衡因子是左右子树高度差）
3. 非叶子节点最多拥有两个子节点；
4. **没有相等的重复节点**

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210720163212.png" alt="image-20210720163211145" style="zoom:80%;" /><img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210720163248.png" alt="image-20210720163248838" style="zoom:80%;" />

#### 用途：

用来折半查找







### （4）B树(B-tree)

==**平衡多路查找树**==

##### 特征：

1. 左小右大

2. ###### 1 **<** ==**非叶节点**的**子节点数**== **<**M    (**M=2则是2叉树,M=3则是3叉**)

3. 根节点**有且只有**1个**关键字**。

4. 非根节点至**少**有M2个**关键字**。

5. 每个节点最**多**有M-1个**关键字**





### （5）B+树

#### 特征：

1. **由B树衍生而来**
2. 根节点至少一个元素
3. 非根节点元素范围：m/2 <= 节点 <= m-1
4. B+树有两种类型的节点：**内部结点**（也称索引结点）和**叶子结点**。
   - **内部节点就是非叶子节点**，内部节点不存储数据，只存储索引，**数据都存储在叶子节点**。
   - 左小右大
5. 每个**叶子都存有邻居的指针**，叶子结点本身依关键字的大小自小而大顺序链接。
6. **父节点**存放**右孩子**的**首元素的指针**。

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210720171837.png" alt="img" style="zoom:80%;" />

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210720172249.png" alt="img" style="zoom:80%;" />

#### b+树优点

- 单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。
- 所有的查询都要查找到叶子节点，**==查询性能稳定==**，**而B树，每个节点都可以查找到数据，所以不稳定。**
- 所有的叶子节点形成了一个有序链表，更加便于查找。





### （6）2-3树

#### 特征：

1. 2-3树不是二叉树
2. **2-节点: **有两个孩子，自身必含一个**数据项**； **左孩子** < 自身数据项 < **右孩子**
3. **3-节点:** 有三个孩子 ，**自身必含两个数据项**（用来查找的），**左孩子** < 左数据项，左数据项<**中孩子**<右数据项，右孩子>右数据项

#### 查找**H**的过程



### （7）2-3-4树

#### 特征：

1. 除了叶子节点，所有的节点都只有2个孩子或3个孩子或4个孩子
2. 有四个孩子的节点原理和三个孩子的原理相同

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210720205814.png" alt="img" style="zoom:80%;" />

1. 所有的叶子节点的深度都是相同的（非叶子结点的**孩子必须连满**）

![image-20210720205855931](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210720205855.png)



### （8）[红黑树](https://www.cnblogs.com/wl889490/p/12733936.html)

#### 性质

- 性质1：每个节点要么是黑色，要么是红色。

- 性质2：**根节点是黑色**。

- 性质3：每个**叶子节点（NIL）是黑色**。

- 性质4：每个红色节点的两个子节点一定都是黑色。 不能有两个红色节点相连。

- 性质5：任意一节点到每个叶子节点的路径都包含数量相同的黑结点。

- 从性质5又可以推出： 性质5.1：如果一个节点存在黑子节点，那么该结点肯定有两个子节点。不然走另一条路就会少一层黑色结点。

#### **红黑树的应用** 

**TreeMap**、**TreeSet**以及JDK1.8的**HashMap**底层都用到了红黑树。

#### **为什么要用红黑树**

为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构



### （9）二叉树的遍历

#### 先序遍历

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/image-20220307145418296.png" alt="image-20220307145418296" style="zoom:50%;" />

### 中序遍历

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/image-20220307145358848.png" alt="image-20220307145358848" style="zoom:50%;" />

### 后序遍历

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/image-20220307145334770.png" alt="image-20220307145334770" style="zoom:50%;" />

根据**前中序求后序**或者**后中序求前序**：

​		根据前/后序确定父节点是哪个

​		根据中序确定子节点在左/右  或者  哪个是儿子哪个是孙子

# 四、Java基础

## 1、访问控制修饰符

- private：仅在本类中可用

- 默认：仅同包中的 本类和子类可用

- protected：同包中的 本类和子类可用、不用包的子类可用

- public：均可用（stu.name）

## 2、hashCode() 作用

`hashCode()` 的作用是获取哈希码（`int` 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。

散列表存储的是键值对(key-value

>当你把对象加入 `HashSet`(自动去重)时，`HashSet` 会先计算对象的 `hashCode` 值来判断对象加入的位置，同时也会与其他已经加入的对象的 `hashCode` 值作比较，如果没有相符的 `hashCode`，直接添加成功
>
>若发现有相同 `hashCode` 值的对象，这时会调用 `equals()` 方法来检查。如果两者相同添加失败。如果不同的话，就会重新散列到其他位置。这样我们就**==大大减少了 `equals` 的次数==**，相应就大大提高了执行速度。

- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等（哈希碰撞）。
- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。
- 如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等。

## 3、基本数据类型

| 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                   |
| :-------- | :--- | :--- | :------ | ------------------------------------------ |
| `byte`    | 8    | 1    | 0       | -128 ~ 127                                 |
| `short`   | 16   | 2    | 0       | -32768 ~ 32767                             |
| `int`     | 32   | 4    | 0       | -2147483648 ~ 2147483647                   |
| `long`    | 64   | 8    | 0L      | -9223372036854775808 ~ 9223372036854775807 |
| `char`    | 16   | 2    | 'u0000' | 0 ~ 65535                                  |
| `float`   | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                     |
| `double`  | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308          |
| `boolean` | 1    |      | false   | true、false                                |

Java 里使用 `long` 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析。

## 4、接口和抽象类区别

- 抽象类单继承、接口多实现
- 抽象类主要用于代码复用
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值

## 5、深拷贝和浅拷贝区别

浅拷贝：浅拷贝会在堆上创建一个新的对象，但是如果原对象的==成员变量是引用类型==，浅拷贝会直接复制内部对象的引用地址

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/image-20220307164755158.png" alt="image-20220307164755158" style="zoom: 80%;" />

深拷贝：开辟了新空间，包括了成员变量

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/image-20220307164837418.png" alt="image-20220307164837418" style="zoom:80%;" />

引用拷贝：还是引用同一个地址

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/image-20220307164845182.png" alt="image-20220307164845182" style="zoom:80%;" />

## 6、Object类

```java
public final native Class<?> getClass()//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。

public native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。
public boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。

protected native Object clone() throws CloneNotSupportedException//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。

public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。

public final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。

public final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。

public final native void wait(long timeout) throws InterruptedException//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。

public final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。

public final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念

protected void finalize() throws Throwable { }//实例被垃圾回收器回收的时候触发的操作
```

## 7、String、StringBuffer、StringBuilder 的区别

- **String**：
  - 每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象
- `StringBuffer`：
  -  对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。
- `StringBuilder` “
  - 并没有对方法进行加同步锁，所以是非线程安全的。

>String str4 = str1 + str2 + str3;中的+实际上通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。

## 8、IO

### （1）某字段不想序列化

transient关键字

```java
private transient int tree=20;
```

### （2）字节流

#### ①FileOutputStream类（字节输出流）

`fos.write(by)`

```java
FileOutputStream fos = new FileOutputStream("E:\\heyifeo.txt");
```

#### ②FileInputStream类（字节输入流）

`fis.read()`

```java
FileInputStream fis = new FileInputStream("E:\\D.txt");
```

#### ③BufferedOutputStream

```java
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("E:\\D.txt"));
```

#### ④BuffferedInputStream



### （2）字符流

#### ①OutputStreamWriter类

`osw.write("我",0,1);//我`

```java
OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("E:\\D.txt"));//默认编码

OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("E:\\D.txt"),"GBK");//指定编码
```

#### ②InputStreamReader

`isr.read()`

```java
InputStreamReader isr = new InputStreamReader(new FileInputStream("E:\\D.txt"));
```

#### ③FileReader

`fr.read()`

```java
FileReader fr = new FileReader ("a. txt") ;
```

#### ④FileWrite

`fw. write (“ch”)`

```java
FileWriter fw = new FileWriter ("b. txt") ;
```

#### ⑤BufferedWrite

`bw. write (“ch”)`

```java
BufferedWriter bw = new BufferedWriter(new FileWriter("E:\\D.txt"));
```

#### ⑥BufferedReader

`br.read()`

```java
BufferedReader br = new BufferedReader(new FileReader("E:\\D.txt"));
```

#### 
